#summary How to configure fake objects
#labels Featured,Phase-Implementation

= How to configure fake objects =

FakeItEasy is all about choise, therefore there is several ways to configure fake objects. All have there benefits and drawbacks.

The methods differs mainly in how you get a hold of the configuration object for the fake, once you have that the configuration is the same in all of the methods.

The methods are:
  * Using the A.CallTo-method.
  * Using the Configure.Fake-method.
  * Importing the namespace FakeItEasy.ExtensionSyntax and using the Configure-extension method.
  * Importing the namespace FakeItEasy.ExtensionSyntax.Full and using any of these two extension methods: AnyCall, CallsTo directly on your fake.
  * Creating fake objects with the new Fake`<`T`>`-syntax and calling the configuration of the fake object.

==Using the A.CallTo-method==
This is the newest and hottest way of configuring fakes, the benefits are that the call to configure is expressed in its entirety, not split up by awkward lambda syntax. It also does not require any extension methods that tend to clutter up IntelliSense.

{{{
var foo = A.Fake<IFoo>();
A.CallTo(() => foo.Baz()).Returns(10);
}}}

==Using the Configure.Fake-method==
This method is going to be deprecated.

==Using the extension syntax==
This is a bit of a compromise, it provides ONE extension method "Configure" so the cluttering of IntelliSense is kept at a minimum.

{{{
using FakeItEasy.ExtensionSyntax;
// ...
var foo = A.Fake<IFoo>();
foo.Configure().CallsTo(x => x.Baz()).Returns(10);
}}}

==Using the full extension syntax==
This is pretty much what your used to if you've used Rhino.Mocks, it provides a very quick way of configuring (and asserting on) your fakes. However there are more extension methods on all your objects.

{{{
using FakeItEasy.ExtensionSyntax.Full;
// ...
var foo = A.Fake<IFoo>();
foo.CallsTo(x => x.Baz()).Returns(10);
}}}


==Using the new Fake`<`T`>`() method==
If you've ever tried Moq out this is probably what you're used to. The benefits are that the whole fake api is very discoverable and it uses no extension methods. The only drawback is that your fake object is not of the faked type but you have to access the FakedObject-property of the object to get to the proxy. It's just a matter of taste.
{{{
var foo = new Fake<IFoo>();
foo.CallsTo(x => x.Baz()).Returns(10);
}}}

= The secret option =
There's nothing in FakeItEasy that ties it to a particular configuration syntax, you can actually provide your own. Every proxy generated by FakeItEasy has a reference to an instance of the FakeItEasy.Api.FakeObject-class, this is at the heart of FakeItEasy and this is where interceptions can be configured. You can easily get a hold of the FakeObject by calling the Fake.GetFakeObject-method with a proxy:

{{{
var foo = A.Fake<IFoo>();
FakeObject fakeObject = Fake.GetFakeObject(foo);
}}}

Once you have this object you can configure it by adding your own rules to it. The rules is of the type FakeItEasy.Api.IFakeObjectRule. You can implement your own rules to do whatever you like.

Lets look at a simple (and stupid) implementation of a custom configuration api. We will create a configuration that instructs all members of the configured object that has a specific return type to return a specified value, to accomplish this we create a new class ReturnValueRule`<T>` which implements the IFakeObjectCallRule interface. Also, we create a static method that adds this rule to fakes.

{{{
public class StupidApi
{
    public static void ConfigureMethodsWithReturnTypeToReturnValue<TFake, TReturnType>(TFake fakedObject, TReturnType value)
    {
        var fake = Fake.GetFakeObject(fakedObject);
        fake.AddRule(new ReturnValueRule<TReturnType> { Value = value });
    }

    private class ReturnValueRule<T>
        : IFakeObjectCallRule
    {
        public T Value;

        public void Apply(IWritableFakeObjectCall fakeObjectCall)
        {
            fakeObjectCall.SetReturnValue(this.Value);
        }

        public bool IsApplicableTo(IFakeObjectCall fakeObjectCall)
        {
            return fakeObjectCall.Method.ReturnType.Equals(typeof(T));
        }

        public int? NumberOfTimesToCall
        {
            get { return null; }
        }
    }

}
}}}

That's all there's to it, we can now call our stupid api like this:

{{{
var foo = A.Fake<IFoo>();
StupidApi.ConfigureMethodsWithReturnTypeToReturnValue(foo, "Configured!");
Console.WriteLine(foo.ToString());
}}}
In this example "Configured!" will be written to the console.